{
  "hash": "3a99eaaa9ea6f571bc8ad1e0f560c570",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Pivoting data\"\nauthor: \"Jeffrey R. Stevens\"\ndate: \"2023-02-24\"\noutput: html_document\nexecute:\n  freeze: auto\n---\n\n\n\nFor these exercises, we'll use a new clean version of the dog breed traits data set. \n\n1. Import data from <https://jeffreyrstevens.quarto.pub/dpavir/data/dog_breed_traits_clean.csv> and assign to `traits`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n\n\n:::\n\n```{.r .cell-code}\ntraits <- read_csv(\"https://jeffreyrstevens.quarto.pub/dpavir/data/dog_breed_traits_clean.csv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 197 Columns: 8\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (3): breed, coat_type, coat_length\ndbl (5): affectionate, children, other_dogs, shedding, grooming\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n:::\n\n\n\n2. Create `traits2` where we delete the coat columns, so we only have breed and ratings data.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntraits2 <- traits |> \n  select(-contains(\"coat\"))\n```\n:::\n\n\n\n3. Is `traits2` tidy?\n\n4. Is `traits2` in wide or long format?\n\n5. Reshape `traits2` so that all of the ratings scores are in a single column called _rating_ with a column labeling what kind of rating it is called _scale_. Assign this to `traits3`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntraits3 <- traits2 |> \n  pivot_longer(affectionate:grooming, names_to = \"scale\", values_to = \"rating\")\n```\n:::\n\n\n\n6. How would we check if `traits3` has the expected number of rows?\n\n7. Create `traits4` by removing the rows with affectionate, children, and other_dogs as values of _scale_.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntraits4 <- traits3 |> \n  filter(!scale %in% c(\"affectionate\", \"children\", \"other_dogs\"))\n```\n:::\n\n\n\n8. Spread out the data into wide format with separate columns for the shedding and grooming data, then create a new column _diff_ that subtracts grooming from shedding ratings.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntraits4 |>\n  pivot_wider(id_cols = breed, names_from = scale, values_from = rating) |> \n  mutate(diff = shedding - grooming)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 197 × 4\n   breed                         shedding grooming  diff\n   <chr>                            <dbl>    <dbl> <dbl>\n 1 Retrievers (Labrador)                4        2     2\n 2 French Bulldogs                      3        1     2\n 3 German Shepherd Dogs                 4        2     2\n 4 Retrievers (Golden)                  4        2     2\n 5 Bulldogs                             3        3     0\n 6 Poodles                              1        4    -3\n 7 Beagles                              3        2     1\n 8 Rottweilers                          3        1     2\n 9 Pointers (German Shorthaired)        3        2     1\n10 Dachshunds                           2        2     0\n# ℹ 187 more rows\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}