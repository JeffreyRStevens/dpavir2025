{
  "hash": "6d683d2516bdae493a6f29b0f5a7c799",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Functions\"\nauthor: \"Jeffrey R. Stevens\"\ndate: \"2025-03-24\"\noutput: html_document\nexecute:\n  freeze: auto\n---\n\n\n\n\n1. Write a function called `mystring` that takes a vector as an argument and returns the first three characters from the string. Test it on `words[1:10]`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(stringr)\nmystring <- function(x) {\n  str_sub(x, 1, 3)\n}\nmystring(words[1:10])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"a\"   \"abl\" \"abo\" \"abs\" \"acc\" \"acc\" \"ach\" \"acr\" \"act\" \"act\"\n```\n\n\n:::\n:::\n\n\n\n2. Add an argument to `mystring()` that allows the user to control how many of the first characters should be returned. Test it on `words[1:10]` with 5 characters.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmystring <- function(x, chars) {\n  str_sub(x, 1, chars)\n}\nmystring(words[1:10], chars = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"a\"     \"able\"  \"about\" \"absol\" \"accep\" \"accou\" \"achie\" \"acros\" \"act\"  \n[10] \"activ\"\n```\n\n\n:::\n:::\n\n\n\n3. Set the default number of characters returned by `mystring()` to be 3 and test that the default works and that you can override the default.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmystring <- function(x, chars = 3) {\n  str_sub(x, 1, chars)\n}\nmystring(words[1:10])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"a\"   \"abl\" \"abo\" \"abs\" \"acc\" \"acc\" \"ach\" \"acr\" \"act\" \"act\"\n```\n\n\n:::\n\n```{.r .cell-code}\nmystring(words[1:10], chars = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"a\"     \"able\"  \"about\" \"absol\" \"accep\" \"accou\" \"achie\" \"acros\" \"act\"  \n[10] \"activ\"\n```\n\n\n:::\n:::\n\n\n\n4. Add a step that checks whether the inputted vector is a character string. If it is, continue to return the truncated strings. If the vector is not a character string, use the `stop()` function to stop the computation and return a message to the console telling the user that the vector was not a character vector. Test your function with a character vector, a numeric vector, and a logical vector.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmystring <- function(x, chars = 3) {\n  if (!is.character(x)) {\n    stop(\"Please enter a character vector.\")\n  } else {\n  str_sub(x, 1, chars)\n  }\n}\n\nmystring(words[1:10])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"a\"   \"abl\" \"abo\" \"abs\" \"acc\" \"acc\" \"ach\" \"acr\" \"act\" \"act\"\n```\n\n\n:::\n\n```{.r .cell-code}\nmystring(1:10)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in mystring(1:10): Please enter a character vector.\n```\n\n\n:::\n\n```{.r .cell-code}\nmystring(c(TRUE, FALSE))\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in mystring(c(TRUE, FALSE)): Please enter a character vector.\n```\n\n\n:::\n:::\n\n\n\n5. Create a function called `parse_my_vector` that does the following:\n  * Allows users to input a vector and a response to the argument `type` that determines whether the vector is a numeric (`\"num\"`), character (`\"char\"`), or logical (`\"logical\"`) vector. There should be no default value. If the user response does not match any of these three strings, stop with a message asking the user to specify one of the three strings.\n  * For each type, checks whether the vector is actually the type specified by the user and stops with a message if they do not match.\n  * For numeric vectors, multiplies by 10. For character vectors, extracts the first three characters. For logical vectors, returns the number of TRUE responses.\n  * Before returning output, prints a message thanking the user.\n  * Returns the original vector and output of the functions described above.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nparse_my_vector <- function(x, type) {\n  if (type == \"num\") {\n    if (is.numeric(x)) {\n      output <- x / 10\n    } else {\n      stop(\"Type response does not match vector type.\")\n    }\n  } else if (type == \"char\") {\n    if (is.character(x)) {\n      output <- str_sub(x, 1, 3)\n    } else {\n      stop(\"Type response does not match vector type.\")\n    }\n  } else if (type == \"logical\") {\n    output <- sum(x)\n  } else {\n    stop(\"Please enter either 'num', 'char', or 'logical'.\")\n  }\n  message(\"Thank you!\")\n  list(x,output)\n}\n```\n:::\n\n\n\n6. Check the following with `parse_my_vector()`:\n  * x = 1:10, type = \"num\"\n  * x = 1:10, type = \"char\"\n  * x = words[1:10], type = \"num\"\n  * x = words[1:10], type = \"char\"\n  * x = c(TRUE, FALSE, TRUE), type = \"num\"\n  * x = c(TRUE, FALSE, TRUE), type = \"logical\"\n  * x = 1:10, type = \"nums\"\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nparse_my_vector(x = 1:10, type = \"num\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThank you!\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n [1]  1  2  3  4  5  6  7  8  9 10\n\n[[2]]\n [1] 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0\n```\n\n\n:::\n\n```{.r .cell-code}\nparse_my_vector(x = 1:10, type = \"char\")\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in parse_my_vector(x = 1:10, type = \"char\"): Type response does not match vector type.\n```\n\n\n:::\n\n```{.r .cell-code}\nparse_my_vector(x = words[1:10], type = \"num\")\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in parse_my_vector(x = words[1:10], type = \"num\"): Type response does not match vector type.\n```\n\n\n:::\n\n```{.r .cell-code}\nparse_my_vector(x = words[1:10], type = \"char\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThank you!\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n [1] \"a\"        \"able\"     \"about\"    \"absolute\" \"accept\"   \"account\" \n [7] \"achieve\"  \"across\"   \"act\"      \"active\"  \n\n[[2]]\n [1] \"a\"   \"abl\" \"abo\" \"abs\" \"acc\" \"acc\" \"ach\" \"acr\" \"act\" \"act\"\n```\n\n\n:::\n\n```{.r .cell-code}\nparse_my_vector(x = c(TRUE, FALSE, TRUE), type = \"num\")\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in parse_my_vector(x = c(TRUE, FALSE, TRUE), type = \"num\"): Type response does not match vector type.\n```\n\n\n:::\n\n```{.r .cell-code}\nparse_my_vector(x = c(TRUE, FALSE, TRUE), type = \"logical\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThank you!\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1]  TRUE FALSE  TRUE\n\n[[2]]\n[1] 2\n```\n\n\n:::\n\n```{.r .cell-code}\nparse_my_vector(x = 1:10, type = \"nums\")\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in parse_my_vector(x = 1:10, type = \"nums\"): Please enter either 'num', 'char', or 'logical'.\n```\n\n\n:::\n:::\n",
    "supporting": [
      "24_functions_answers_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}