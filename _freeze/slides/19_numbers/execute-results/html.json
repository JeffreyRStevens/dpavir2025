{
  "hash": "c5ecf3539b32fd0734303249f885bf8a",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Numbers\"\nauthor: \"Jeff Stevens\"\ndate: \"2023-03-06\"\ndate-format: iso\nexecute:\n  echo: true\n  freeze: true\nformat:\n  revealjs: \n    theme: custom.scss\n    slide-number: true\n    code-line-numbers: false\n    highlight-style: github\n    code-overflow: wrap\n    footer: \"[DPaViR 2023](https://jeffreyrstevens.quarto.pub/dpavir)\"\n    code-link: true\n---\n\n\n\n\n\n# Introduction\n\n\n## The problem\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\nWhat's different between these data sets? \n\nWhat is needed to create `data2` from `data1`?\n\n:::: {.columns}\n\n::: {.column width=\"45%\"}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 × 3\n     val1   val2    val3\n    <dbl>  <dbl>   <dbl>\n 1 0.773  0.470  0.00431\n 2 0.827  0.751  0.00923\n 3 0.746  0.220  0.00814\n 4 0.953  0.199  0.00767\n 5 0.298  0.894  0.00221\n 6 0.860  0.0149 0.00499\n 7 0.0460 0.956  0.00779\n 8 0.947  0.162  0.00875\n 9 0.511  0.189  0.00986\n10 0.712  0.0969 0.00862\n11 0.944  0.370  0.00209\n12 0.834  0.585  0.00420\n```\n\n\n:::\n:::\n\n\n\n:::\n\n::: {.column width=\"55%\"}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 × 3\n   percent_val1 log_val2 val3   \n          <dbl>    <dbl> <chr>  \n 1         77.3  -0.756  4.3e-03\n 2         82.7  -0.287  9.2e-03\n 3         74.6  -1.51   8.1e-03\n 4         95.3  -1.61   7.7e-03\n 5         29.8  -0.113  2.2e-03\n 6         86.0  -4.20   5.0e-03\n 7          4.6  -0.0452 7.8e-03\n 8         94.7  -1.82   8.7e-03\n 9         51.1  -1.67   9.9e-03\n10         71.2  -2.33   8.6e-03\n11         94.4  -0.994  2.1e-03\n12         83.4  -0.536  4.2e-03\n```\n\n\n:::\n:::\n\n\n\n:::\n\n::::\n\n\n## Set-up\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(nycflights13)\n```\n:::\n\n\n\n\n\n## Types of numbers\n\nDoubles are floating point numbers\n\n::: {.callout-note}\n**Floating point number:** a number without a fixed number of digits after the decimal point\n:::\n\nFloating point numbers ≈ scientific notation\n\n\n## Types of numbers\n\nComputer memory is limited, so you cannot store numbers with infinite precision and floating points are stored imprecisely\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt(2) ^ 2 == 2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\n1 / 49 * 49 == 1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n\n\n\n\n# Comparing and counting\n\n\n## Comparing numbers\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1\ny <- 1.00000000000001\nz <- 1.001\n```\n:::\n\n\n\n\n::: {.fragment}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx == y\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nall.equal(x, y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nall.equal(x, z)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Mean relative difference: 0.001\"\n```\n\n\n:::\n\n```{.r .cell-code}\nall.equal(x, z, tolerance = 1e-2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n:::\n:::\n\n::: {.column width=\"50%\"}\n\n::: {.fragment}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt(2) ^ 2 == 2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nall.equal(sqrt(2) ^ 2, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\ndplyr::near(sqrt(2) ^ 2, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n:::\n\n:::\n::::\n\n<!-- ## Parsing numbers -->\n\n<!-- Sometimes, numbers come in as character string, occasionally with weird formatting. -->\n\n<!-- To parse numbers that come in with scientific notation, use `readr::parse_double()`: -->\n<!-- ```{r} -->\n<!-- (num_char <- \"1e3\") -->\n<!-- typeof(num_char) -->\n<!-- parse_double(num_char) -->\n<!-- ``` -->\n\n\n<!-- ## Parsing numbers -->\n\n<!-- To parse numbers that come in with monetary units or percent signs, use `readr::parse_number()`: -->\n<!-- ```{r} -->\n<!-- (num_char <- c(\"$1,234\", \"USD 3,513\", \"59%\")) -->\n<!-- typeof(num_char) -->\n<!-- parse_number(num_char) -->\n<!-- ``` -->\n\n\n## Counts\n\nAs a reminder, we've already seen how to use `dplyr::count()`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncount(flights, carrier)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 16 × 2\n   carrier     n\n   <chr>   <int>\n 1 9E      18460\n 2 AA      32729\n 3 AS        714\n 4 B6      54635\n 5 DL      48110\n 6 EV      54173\n 7 F9        685\n 8 FL       3260\n 9 HA        342\n10 MQ      26397\n11 OO         32\n12 UA      58665\n13 US      20536\n14 VX       5162\n15 WN      12275\n16 YV        601\n```\n\n\n:::\n:::\n\n\n\n\n\n## Counts\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\nWe can also automatically sort by count.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncount(flights, carrier, sort = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 16 × 2\n   carrier     n\n   <chr>   <int>\n 1 UA      58665\n 2 B6      54635\n 3 EV      54173\n 4 DL      48110\n 5 AA      32729\n 6 MQ      26397\n 7 US      20536\n 8 9E      18460\n 9 WN      12275\n10 VX       5162\n11 FL       3260\n12 AS        714\n13 F9        685\n14 YV        601\n15 HA        342\n16 OO         32\n```\n\n\n:::\n:::\n\n\n\n:::\n\n::: {.column width=\"50%\"}\nAnd sum up totals instead of just count\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncount(flights, carrier, wt = distance)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 16 × 2\n   carrier        n\n   <chr>      <dbl>\n 1 9E       9788152\n 2 AA      43864584\n 3 AS       1715028\n 4 B6      58384137\n 5 DL      59507317\n 6 EV      30498951\n 7 F9       1109700\n 8 FL       2167344\n 9 HA       1704186\n10 MQ      15033955\n11 OO         16026\n12 UA      89705524\n13 US      11365778\n14 VX      12902327\n15 WN      12229203\n16 YV        225395\n```\n\n\n:::\n:::\n\n\n\n:::\n\n::::\n\n\n## Counts\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\nRemember `n()` counts inside a `summarise()`\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  group_by(carrier) |> \n  summarise(n = n())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 16 × 2\n   carrier     n\n   <chr>   <int>\n 1 9E      18460\n 2 AA      32729\n 3 AS        714\n 4 B6      54635\n 5 DL      48110\n 6 EV      54173\n 7 F9        685\n 8 FL       3260\n 9 HA        342\n10 MQ      26397\n11 OO         32\n12 UA      58665\n13 US      20536\n14 VX       5162\n15 WN      12275\n16 YV        601\n```\n\n\n:::\n:::\n\n\n\n:::\n\n::: {.column width=\"50%\"}\n\n::: {.fragment}\n\n`n_distinct()` counts instances within a group\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  group_by(dest) |> \n  summarise(carriers = n_distinct(carrier))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 105 × 2\n   dest  carriers\n   <chr>    <int>\n 1 ABQ          1\n 2 ACK          1\n 3 ALB          1\n 4 ANC          1\n 5 ATL          7\n 6 AUS          6\n 7 AVL          2\n 8 BDL          2\n 9 BGR          2\n10 BHM          1\n# ℹ 95 more rows\n```\n\n\n:::\n:::\n\n\n\n:::\n:::\n\n::::\n\n\n## Counting NAs\n\nTo count `NA`s, you can `sum()` up `TRUE` responses to `is.na()`\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  group_by(dest) |> \n  summarize(n_cancelled = sum(is.na(dep_time)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 105 × 2\n   dest  n_cancelled\n   <chr>       <int>\n 1 ABQ             0\n 2 ACK             0\n 3 ALB            20\n 4 ANC             0\n 5 ATL           317\n 6 AUS            21\n 7 AVL            12\n 8 BDL            31\n 9 BGR            15\n10 BHM            25\n# ℹ 95 more rows\n```\n\n\n:::\n:::\n\n\n\n\n\n## Counting NAs\n\nThis trick can be used for any logical vector\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(flights$month == 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 27004\n```\n\n\n:::\n\n```{.r .cell-code}\nnrow(filter(flights, month == 1))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 27004\n```\n\n\n:::\n:::\n\n\n\n\n\n# Transforming numbers\n\n## Operations\n\nMathematical operators are recycled across all elements in a vector\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n0:10 * 5\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  0  5 10 15 20 25 30 35 40 45 50\n```\n\n\n:::\n:::\n\n\n\n\n::: {.fragment}\nYou can operate with vectors > 1, but the larger vector must be a multiple of the smaller vector\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n0:10 * c(5, 6)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in 0:10 * c(5, 6): longer object length is not a multiple of shorter\nobject length\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  0  6 10 18 20 30 30 42 40 54 50\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n0:11 * c(5, 6)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  0  6 10 18 20 30 30 42 40 54 50 66\n```\n\n\n:::\n:::\n\n\n\n:::\n\n\n## Mathematical transformations\n\n:::: {.columns}\n\n::: {.column width=\"30%\"}\n\n* `sqrt()`\n* `log()`\n* `log10()`\n* `log2()`\n* `sin()`\n* `asin()`\n:::\n\n::: {.column width=\"70%\"}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt(seq(0, 100, 10))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  0.000000  3.162278  4.472136  5.477226  6.324555  7.071068  7.745967\n [8]  8.366600  8.944272  9.486833 10.000000\n```\n\n\n:::\n\n```{.r .cell-code}\nlog(runif(10))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] -0.3921567 -0.3017750 -2.4044192 -0.6672081 -0.3630729 -1.9276563\n [7] -1.0672688 -4.2340097 -0.8112143 -1.0013072\n```\n\n\n:::\n\n```{.r .cell-code}\nasin(sqrt(runif(10)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 0.8077234 1.1635879 0.1599809 0.8139120 0.5528058 0.6495491 1.2270613\n [8] 0.9685195 0.7673122 0.8240033\n```\n\n\n:::\n:::\n\n\n\n:::\n::::\n\n## Rounding\n\nControl significant digits with `round()`\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nround(123.456, 2)  # two digits\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 123.46\n```\n\n\n:::\n\n```{.r .cell-code}\nround(123.456, 1)  # one digit\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 123.5\n```\n\n\n:::\n\n```{.r .cell-code}\nround(123.456) # whole number\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 123\n```\n\n\n:::\n\n```{.r .cell-code}\nround(123.456, -1) # round to nearest ten\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 120\n```\n\n\n:::\n\n```{.r .cell-code}\nround(123.456, -2) # round to nearest hundred\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 100\n```\n\n\n:::\n:::\n\n\n\n\n<!-- ## Rounding -->\n\n<!-- But weirdness for 0.5s with even digits -->\n\n<!-- ```{r} -->\n<!-- round(c(1.5, 2.5)) -->\n<!-- ``` -->\n\n<!-- To avoid, use `ceiling()` -->\n\n<!-- ```{r} -->\n<!-- ceiling(c(1.5, 2.5)) -->\n<!-- ``` -->\n\n\n# Formatting numbers\n\n\n## Formatting\n\nWhen numbers get too big, too small,  or need other formatting, use `format()`\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(x <- 0.0020)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.002\n```\n\n\n:::\n\n```{.r .cell-code}\nformat(x, scientific = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2e-03\"\n```\n\n\n:::\n\n```{.r .cell-code}\nformat(x, nsmall = 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"0.0020\"\n```\n\n\n:::\n:::\n\n\n\n:::\n\n::: {.column width=\"50%\"}\n\n::: {.fragment}\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(y <- 12345678.9)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 12345679\n```\n\n\n:::\n\n```{.r .cell-code}\nformat(y, scientific = TRUE, \n       digits = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1.23e+07\"\n```\n\n\n:::\n\n```{.r .cell-code}\nformat(y, big.mark = \",\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"12,345,679\"\n```\n\n\n:::\n:::\n\n\n\n:::\n:::\n::::\n\n\n## Cutting numbers into ranges\n\nIf you need to bin numbers into ranges, use `cut()`\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1)\n(x <- runif(12, min = 0, max = 100))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 26.550866 37.212390 57.285336 90.820779 20.168193 89.838968 94.467527\n [8] 66.079779 62.911404  6.178627 20.597457 17.655675\n```\n\n\n:::\n\n```{.r .cell-code}\ncut(x, breaks = c(0, 33, 66, 100))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] (0,33]   (33,66]  (33,66]  (66,100] (0,33]   (66,100] (66,100] (66,100]\n [9] (33,66]  (0,33]   (0,33]   (0,33]  \nLevels: (0,33] (33,66] (66,100]\n```\n\n\n:::\n:::\n\n\n\n::: {.fragment}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncut(x, breaks = c(0, 33, 66, 100), labels = c(\"Low\", \"Medium\", \"High\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] Low    Medium Medium High   Low    High   High   High   Medium Low   \n[11] Low    Low   \nLevels: Low Medium High\n```\n\n\n:::\n:::\n\n\n\n:::\n\n\n<!-- ## Offsets -->\n\n<!-- You many need to work with numbers after (`dplyr::lag()`) or before (`dplyr::lead()`) the current element -->\n\n<!-- ```{r} -->\n<!-- (x <- c(2, 5, 11, 11, 19, 35)) -->\n<!-- lag(x) -->\n<!-- x - lag(x) -->\n<!-- ``` -->\n\n<!-- ```{r} -->\n<!-- lead(x) -->\n<!-- x - lead(x) -->\n<!-- ``` -->\n\n\n<!-- # Summarizing numbers -->\n\n<!-- ## Summary functions -->\n\n<!-- :::: {.columns} -->\n\n<!-- ::: {.column width=\"50%\"} -->\n\n<!-- * `mean()` -->\n<!-- * `median()` -->\n<!-- * `min()` -->\n<!-- * `max()` -->\n<!-- * `sd()` -->\n<!-- ::: -->\n\n<!-- ::: {.column width=\"50%\"} -->\n\n<!-- * `IQR()` -->\n\n<!-- ```{r} -->\n<!-- IQR(x) -->\n<!-- ``` -->\n\n<!-- * `quantile()` -->\n\n<!-- ```{r} -->\n<!-- quantile(x) -->\n<!-- ``` -->\n<!-- ::: -->\n<!-- :::: -->\n\n\n## Solving the problem\n\n:::: {.columns}\n\n::: {.column width=\"45%\"}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 × 3\n     val1   val2    val3\n    <dbl>  <dbl>   <dbl>\n 1 0.773  0.470  0.00431\n 2 0.827  0.751  0.00923\n 3 0.746  0.220  0.00814\n 4 0.953  0.199  0.00767\n 5 0.298  0.894  0.00221\n 6 0.860  0.0149 0.00499\n 7 0.0460 0.956  0.00779\n 8 0.947  0.162  0.00875\n 9 0.511  0.189  0.00986\n10 0.712  0.0969 0.00862\n11 0.944  0.370  0.00209\n12 0.834  0.585  0.00420\n```\n\n\n:::\n:::\n\n\n\n:::\n\n::: {.column width=\"55%\"}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 × 3\n   percent_val1 log_val2 val3   \n          <dbl>    <dbl> <chr>  \n 1         77.3  -0.756  4.3e-03\n 2         82.7  -0.287  9.2e-03\n 3         74.6  -1.51   8.1e-03\n 4         95.3  -1.61   7.7e-03\n 5         29.8  -0.113  2.2e-03\n 6         86.0  -4.20   5.0e-03\n 7          4.6  -0.0452 7.8e-03\n 8         94.7  -1.82   8.7e-03\n 9         51.1  -1.67   9.9e-03\n10         71.2  -2.33   8.6e-03\n11         94.4  -0.994  2.1e-03\n12         83.4  -0.536  4.2e-03\n```\n\n\n:::\n:::\n\n\n\n:::\n\n::::\n\n\n## Let's code!\n\n[Numbers](../code/19_numbers.html){target=\"_blank\"} [[Rmd](../code/19_numbers.Rmd){target=\"_blank\"}]\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}