{
  "hash": "3a2e5f9eddfc0829609e82963df75549",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Numbers\"\nauthor: \"Jeff Stevens\"\ndate: \"2025-03-05\"\ndate-format: iso\nexecute:\n  echo: true\n  freeze: true\nformat:\n  revealjs: \n    theme: custom.scss\n    slide-number: true\n    code-line-numbers: false\n    highlight-style: github\n    code-overflow: wrap\n    footer: \"[DPaViR 2025](https://jeffreyrstevens.github.io/dpavir2025)\"\n    code-link: true\n    logo: \"../logo/dpavir_hex.png\"\n---\n\n\n\n\n\n# Review\n\n## Group data wrangling challenge\n\nUsing the `penguins` data set from the {palmerpenguins} package, recreate this data frame.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(palmerpenguins)\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 4\n  species   island     male female\n  <fct>     <fct>     <dbl>  <dbl>\n1 Adelie    Torgersen 4035.  3396.\n2 Adelie    Biscoe    4050   3369.\n3 Adelie    Dream     4046.  3344.\n4 Chinstrap Dream     3939.  3527.\n```\n\n\n:::\n:::\n\n\n\n\n\n# Introduction\n\n## Mental model of data analysis\n\n![](../images/data_analysis_workflow.png){fig-align=\"center\"}\n\n\n\n## The problem\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\nWhat's different between these data sets? \n\nWhat is needed to create `data2` from `data1`?\n\n:::: {.columns}\n\n::: {.column width=\"45%\"}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```{style='font-size: 52%'}\n# A tibble: 12 × 3\n    val1   val2    val3\n   <dbl>  <dbl>   <dbl>\n 1 0.372 0.129  0.00394\n 2 0.338 0.898  0.00925\n 3 0.889 0.324  0.00762\n 4 0.736 0.477  0.00902\n 5 0.493 0.928  0.00934\n 6 0.909 0.200  0.00142\n 7 0.650 0.846  0.00258\n 8 0.535 0.0300 0.00172\n 9 0.202 0.490  0.00329\n10 0.613 0.649  0.00457\n11 0.666 0.684  0.00325\n12 0.510 0.356  0.00217\n```\n\n\n:::\n:::\n\n\n\n:::\n\n::: {.column width=\"55%\"}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```{style='font-size: 52%'}\n# A tibble: 12 × 3\n   percent_val1 log_val2 val3   \n          <dbl>    <dbl> <chr>  \n 1         37.2  -2.05   3.9e-03\n 2         33.8  -0.107  9.3e-03\n 3         88.9  -1.13   7.6e-03\n 4         73.6  -0.740  9.0e-03\n 5         49.3  -0.0747 9.3e-03\n 6         90.9  -1.61   1.4e-03\n 7         65.0  -0.167  2.6e-03\n 8         53.5  -3.51   1.7e-03\n 9         20.2  -0.713  3.3e-03\n10         61.3  -0.432  4.6e-03\n11         66.6  -0.379  3.3e-03\n12         51    -1.03   2.2e-03\n```\n\n\n:::\n:::\n\n\n\n:::\n\n::::\n\n\n## Set-up\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(nycflights13)\n```\n:::\n\n\n\n\n\n<!-- ## Types of numbers -->\n\n<!-- Doubles are floating point numbers -->\n\n<!-- ::: {.callout-note} -->\n<!-- **Floating point number:** a number without a fixed number of digits after the decimal point -->\n<!-- ::: -->\n\n<!-- Floating point numbers ≈ scientific notation -->\n\n\n<!-- ## Types of numbers -->\n\n<!-- Computer memory is limited, so you cannot store numbers with infinite precision and floating points are stored imprecisely -->\n\n<!-- ```{r} -->\n<!-- sqrt(2) ^ 2 == 2 -->\n<!-- ``` -->\n\n\n# Comparing and counting\n\n\n## Comparing numbers\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1\ny <- 1.00000000000001\nz <- 1.001\n```\n:::\n\n\n\n\n::: {.fragment}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx == y\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nall.equal(x, y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nall.equal(x, z)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Mean relative difference: 0.001\"\n```\n\n\n:::\n\n```{.r .cell-code}\nall.equal(x, z, tolerance = 1e-2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n:::\n:::\n\n::: {.column width=\"50%\"}\n\n::: {.fragment}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt(2) ^ 2 == 2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nall.equal(sqrt(2) ^ 2, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\ndplyr::near(sqrt(2) ^ 2, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n:::\n\n:::\n::::\n\n<!-- ## Parsing numbers -->\n\n<!-- Sometimes, numbers come in as character string, occasionally with weird formatting. -->\n\n<!-- To parse numbers that come in with scientific notation, use `readr::parse_double()`: -->\n<!-- ```{r} -->\n<!-- (num_char <- \"1e3\") -->\n<!-- typeof(num_char) -->\n<!-- parse_double(num_char) -->\n<!-- ``` -->\n\n\n<!-- ## Parsing numbers -->\n\n<!-- To parse numbers that come in with monetary units or percent signs, use `readr::parse_number()`: -->\n<!-- ```{r} -->\n<!-- (num_char <- c(\"$1,234\", \"USD 3,513\", \"59%\")) -->\n<!-- typeof(num_char) -->\n<!-- parse_number(num_char) -->\n<!-- ``` -->\n\n\n## Counts\n\nAs a reminder, we've already seen how to use `dplyr::count()`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncount(flights, carrier)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 16 × 2\n   carrier     n\n   <chr>   <int>\n 1 9E      18460\n 2 AA      32729\n 3 AS        714\n 4 B6      54635\n 5 DL      48110\n 6 EV      54173\n 7 F9        685\n 8 FL       3260\n 9 HA        342\n10 MQ      26397\n11 OO         32\n12 UA      58665\n13 US      20536\n14 VX       5162\n15 WN      12275\n16 YV        601\n```\n\n\n:::\n:::\n\n\n\n\n\n## Counts\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\nWe can also automatically sort by count.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncount(flights, carrier, sort = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 16 × 2\n   carrier     n\n   <chr>   <int>\n 1 UA      58665\n 2 B6      54635\n 3 EV      54173\n 4 DL      48110\n 5 AA      32729\n 6 MQ      26397\n 7 US      20536\n 8 9E      18460\n 9 WN      12275\n10 VX       5162\n11 FL       3260\n12 AS        714\n13 F9        685\n14 YV        601\n15 HA        342\n16 OO         32\n```\n\n\n:::\n:::\n\n\n\n:::\n\n::: {.column width=\"50%\"}\nAnd sum up totals instead of just count\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncount(flights, carrier, wt = distance)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 16 × 2\n   carrier        n\n   <chr>      <dbl>\n 1 9E       9788152\n 2 AA      43864584\n 3 AS       1715028\n 4 B6      58384137\n 5 DL      59507317\n 6 EV      30498951\n 7 F9       1109700\n 8 FL       2167344\n 9 HA       1704186\n10 MQ      15033955\n11 OO         16026\n12 UA      89705524\n13 US      11365778\n14 VX      12902327\n15 WN      12229203\n16 YV        225395\n```\n\n\n:::\n:::\n\n\n\n:::\n\n::::\n\n\n## Counts\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\nRemember `n()` counts inside a `summarise()`\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  group_by(carrier) |> \n  summarise(n = n())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 16 × 2\n   carrier     n\n   <chr>   <int>\n 1 9E      18460\n 2 AA      32729\n 3 AS        714\n 4 B6      54635\n 5 DL      48110\n 6 EV      54173\n 7 F9        685\n 8 FL       3260\n 9 HA        342\n10 MQ      26397\n11 OO         32\n12 UA      58665\n13 US      20536\n14 VX       5162\n15 WN      12275\n16 YV        601\n```\n\n\n:::\n:::\n\n\n\n:::\n\n::: {.column width=\"50%\"}\n\n::: {.fragment}\n\n`n_distinct()` counts instances within a group\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  group_by(dest) |> \n  summarise(carriers = \n              n_distinct(carrier))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 105 × 2\n   dest  carriers\n   <chr>    <int>\n 1 ABQ          1\n 2 ACK          1\n 3 ALB          1\n 4 ANC          1\n 5 ATL          7\n 6 AUS          6\n 7 AVL          2\n 8 BDL          2\n 9 BGR          2\n10 BHM          1\n# ℹ 95 more rows\n```\n\n\n:::\n:::\n\n\n\n:::\n:::\n\n::::\n\n\n## Counting NAs\n\nTo count `NA`s, you can `sum()` up `TRUE` responses to `is.na()`\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  group_by(dest) |> \n  summarize(n_cancelled = sum(is.na(dep_time)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 105 × 2\n   dest  n_cancelled\n   <chr>       <int>\n 1 ABQ             0\n 2 ACK             0\n 3 ALB            20\n 4 ANC             0\n 5 ATL           317\n 6 AUS            21\n 7 AVL            12\n 8 BDL            31\n 9 BGR            15\n10 BHM            25\n# ℹ 95 more rows\n```\n\n\n:::\n:::\n\n\n\n\n\n## Counting NAs\n\nThis trick can be used for any logical vector\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(flights$month == 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 27004\n```\n\n\n:::\n\n```{.r .cell-code}\nnrow(filter(flights, month == 1))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 27004\n```\n\n\n:::\n:::\n\n\n\n\n\n# Transforming numbers\n\n<!-- ## Operations -->\n\n<!-- Mathematical operators are recycled across all elements in a vector -->\n\n<!-- ```{r} -->\n<!-- 0:10 * 5 -->\n<!-- ``` -->\n\n<!-- ::: {.fragment} -->\n<!-- You can operate with vectors > 1, but the larger vector must be a multiple of the smaller vector -->\n<!-- ```{r warning = TRUE} -->\n<!-- 0:10 * c(5, 6) -->\n<!-- ``` -->\n<!-- ```{r} -->\n<!-- 0:11 * c(5, 6) -->\n<!-- ``` -->\n<!-- ::: -->\n\n\n## Mathematical transformations\n\n:::: {.columns}\n\n::: {.column width=\"30%\"}\n\n* `sqrt()`\n* `log()`\n* `log10()`\n* `log2()`\n* `sin()`\n* `asin()`\n:::\n\n::: {.column width=\"70%\"}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt(seq(0, 100, 10))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  0.000000  3.162278  4.472136  5.477226  6.324555  7.071068  7.745967\n [8]  8.366600  8.944272  9.486833 10.000000\n```\n\n\n:::\n\n```{.r .cell-code}\nlog(runif(10))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] -1.65340685 -1.29070057 -1.07721774 -0.67318319 -0.16257538 -1.08017070\n [7] -0.54354157 -0.04112082 -0.58662299 -1.58314303\n```\n\n\n:::\n\n```{.r .cell-code}\nasin(sqrt(runif(10)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 0.6346852 1.0213321 0.8641012 0.3110083 1.1331782 1.0825151 1.2655997\n [8] 0.3102413 1.0683179 1.1974808\n```\n\n\n:::\n:::\n\n\n\n:::\n::::\n\n## Rounding\n\nControl significant digits with `round()`\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nround(123.456, 2)  # two digits\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 123.46\n```\n\n\n:::\n\n```{.r .cell-code}\nround(123.456, 1)  # one digit\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 123.5\n```\n\n\n:::\n\n```{.r .cell-code}\nround(123.456) # whole number\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 123\n```\n\n\n:::\n\n```{.r .cell-code}\nround(123.456, -1) # round to nearest ten\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 120\n```\n\n\n:::\n\n```{.r .cell-code}\nround(123.456, -2) # round to nearest hundred\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 100\n```\n\n\n:::\n:::\n\n\n\n\n<!-- ## Rounding -->\n\n<!-- But weirdness for 0.5s with even digits -->\n\n<!-- ```{r} -->\n<!-- round(c(1.5, 2.5)) -->\n<!-- ``` -->\n\n<!-- To avoid, use `ceiling()` -->\n\n<!-- ```{r} -->\n<!-- ceiling(c(1.5, 2.5)) -->\n<!-- ``` -->\n\n\n# Formatting numbers\n\n\n## Formatting\n\nWhen numbers get too big, too small,  or need other formatting, use `format()`\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(x <- 0.0020)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.002\n```\n\n\n:::\n\n```{.r .cell-code}\nformat(x, scientific = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2e-03\"\n```\n\n\n:::\n\n```{.r .cell-code}\nformat(x, nsmall = 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"0.0020\"\n```\n\n\n:::\n:::\n\n\n\n:::\n\n::: {.column width=\"50%\"}\n\n::: {.fragment}\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(y <- 12345678.9)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 12345679\n```\n\n\n:::\n\n```{.r .cell-code}\nformat(y, scientific = TRUE, \n       digits = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1.23e+07\"\n```\n\n\n:::\n\n```{.r .cell-code}\nformat(y, big.mark = \",\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"12,345,679\"\n```\n\n\n:::\n:::\n\n\n\n:::\n:::\n::::\n\n\n## Cutting numbers into ranges\n\nIf you need to bin numbers into ranges, use `cut()`\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1)\n(x <- runif(12, min = 0, max = 100))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 26.550866 37.212390 57.285336 90.820779 20.168193 89.838968 94.467527\n [8] 66.079779 62.911404  6.178627 20.597457 17.655675\n```\n\n\n:::\n\n```{.r .cell-code}\ncut(x, breaks = c(0, 33, 66, 100))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] (0,33]   (33,66]  (33,66]  (66,100] (0,33]   (66,100] (66,100] (66,100]\n [9] (33,66]  (0,33]   (0,33]   (0,33]  \nLevels: (0,33] (33,66] (66,100]\n```\n\n\n:::\n:::\n\n\n\n::: {.fragment}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncut(x, breaks = 3, labels = c(\"Low\", \"Medium\", \"High\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] Low    Medium Medium High   Low    High   High   High   Medium Low   \n[11] Low    Low   \nLevels: Low Medium High\n```\n\n\n:::\n:::\n\n\n\n:::\n\n\n<!-- ## Offsets -->\n\n<!-- You many need to work with numbers after (`dplyr::lag()`) or before (`dplyr::lead()`) the current element -->\n\n<!-- ```{r} -->\n<!-- (x <- c(2, 5, 11, 11, 19, 35)) -->\n<!-- lag(x) -->\n<!-- x - lag(x) -->\n<!-- ``` -->\n\n<!-- ```{r} -->\n<!-- lead(x) -->\n<!-- x - lead(x) -->\n<!-- ``` -->\n\n\n<!-- # Summarizing numbers -->\n\n<!-- ## Summary functions -->\n\n<!-- :::: {.columns} -->\n\n<!-- ::: {.column width=\"50%\"} -->\n\n<!-- * `mean()` -->\n<!-- * `median()` -->\n<!-- * `min()` -->\n<!-- * `max()` -->\n<!-- * `sd()` -->\n<!-- ::: -->\n\n<!-- ::: {.column width=\"50%\"} -->\n\n<!-- * `IQR()` -->\n\n<!-- ```{r} -->\n<!-- IQR(x) -->\n<!-- ``` -->\n\n<!-- * `quantile()` -->\n\n<!-- ```{r} -->\n<!-- quantile(x) -->\n<!-- ``` -->\n<!-- ::: -->\n<!-- :::: -->\n\n\n## Solving the problem\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nnrows <- 12\nset.seed(20250305)\ndata1 <- tibble(val1 = runif(nrows), \n                val2 = runif(nrows), \n                val3 = runif(nrows, 0.001, 0.01))\n```\n:::\n\n\n\n\n\n## Solving the problem\n\n:::: {.columns}\n\n::: {.column width=\"45%\"}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```{style='font-size: 52%'}\n# A tibble: 12 × 3\n    val1   val2    val3\n   <dbl>  <dbl>   <dbl>\n 1 0.372 0.129  0.00394\n 2 0.338 0.898  0.00925\n 3 0.889 0.324  0.00762\n 4 0.736 0.477  0.00902\n 5 0.493 0.928  0.00934\n 6 0.909 0.200  0.00142\n 7 0.650 0.846  0.00258\n 8 0.535 0.0300 0.00172\n 9 0.202 0.490  0.00329\n10 0.613 0.649  0.00457\n11 0.666 0.684  0.00325\n12 0.510 0.356  0.00217\n```\n\n\n:::\n:::\n\n\n\n:::\n\n::: {.column width=\"55%\"}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```{style='font-size: 52%'}\n# A tibble: 12 × 3\n   percent_val1 log_val2 val3   \n          <dbl>    <dbl> <chr>  \n 1         37.2  -2.05   3.9e-03\n 2         33.8  -0.107  9.3e-03\n 3         88.9  -1.13   7.6e-03\n 4         73.6  -0.740  9.0e-03\n 5         49.3  -0.0747 9.3e-03\n 6         90.9  -1.61   1.4e-03\n 7         65.0  -0.167  2.6e-03\n 8         53.5  -3.51   1.7e-03\n 9         20.2  -0.713  3.3e-03\n10         61.3  -0.432  4.6e-03\n11         66.6  -0.379  3.3e-03\n12         51    -1.03   2.2e-03\n```\n\n\n:::\n:::\n\n\n\n:::\n\n::::\n\n\n## Let's code!\n\n[Numbers](../code/19_numbers.html){target=\"_blank\"}\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}