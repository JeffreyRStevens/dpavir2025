{
  "hash": "ffd10aca99de0a3e049a6c40149c1bee",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Matching patterns\"\nauthor: \"Jeff Stevens\"\ndate: \"2025-03-10\"\ndate-format: iso\nexecute:\n  echo: true\n  freeze: auto\nformat:\n  revealjs: \n    theme: custom.scss\n    slide-number: true\n    code-line-numbers: false\n    highlight-style: github\n    code-overflow: wrap\n    footer: \"[DPaViR 2025](https://jeffreyrstevens.github.io/dpavir2025)\"\n    code-link: true\n    logo: \"../logo/dpavir_hex.png\"\n---\n\n\n\n\n\n# Introduction\n\n\n## The problem\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\nWhat's different between these data sets? \n\nWhat is needed to create `data2` from `data1`?\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```{style='font-size: 50%'}\n# A tibble: 12 × 3\n   time      species  resp \n   <chr>     <chr>    <chr>\n 1 early-day dogfish  yes  \n 2 mid-day   bear dog no   \n 3 late-day  dog      yes  \n 4 daytime   dogfish  no   \n 5 early-day cat      yes  \n 6 mid-day   cat      no   \n 7 late-day  dogfish  no   \n 8 daytime   bear dog no   \n 9 early-day dogfish  <NA> \n10 mid-day   catfish  yes  \n11 late-day  cat      yes  \n12 daytime   bear dog yes  \n```\n\n\n:::\n:::\n\n\n\n:::\n\n::: {.column width=\"50%\"}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```{style='font-size: 50%'}\n# A tibble: 8 × 3\n  time      species  resp   \n  <chr>     <chr>    <chr>  \n1 early-Day dogfish  yes    \n2 mid-Day   bear dog no     \n3 late-Day  dog      yes    \n4 daytime   dogfish  no     \n5 late-Day  dogfish  no     \n6 daytime   bear dog no     \n7 early-Day dogfish  no data\n8 daytime   bear dog yes    \n```\n\n\n:::\n:::\n\n\n\n:::\n\n::::\n\n\n## Set-up\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(palmerpenguins)\n```\n:::\n\n\n\n\n\n## Mental model\n\n![](../images/mentalmodel_strings.png){fig-align=\"center\"}\n\n\n## Strings with {stringr}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(stringr)\n```\n:::\n\n\n\n\n![](../images/stringr_allisonhorst.png){fig-align=\"center\" width=\"58%\"}\n\n![](../images/stringr_hex.png){.absolute width=\"15%\" top=\"0%\" left=\"90%\"}\n\n\n::: {.aside}\nSource: [Allison Horst](https://allisonhorst.com/r-packages-functions)\n:::\n\n\n# Patterns\n\n\n## Regular expressions\n\nConcise and powerful language for describing patterns within strings\n\n(regex for short)\n\n![](../images/regex_meme2.jpeg){fig-align=\"center\" width=\"40%\"}\n\n\n## Regular expressions\n\nHere's the regex I used to detect IP addresses in `{excluder}`:\n\n`^(?:(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])(\\.(?!$)|$)){4}$`\n\n![](../images/regex_meme.jpeg){.absolute height=\"50%\" top=\"40%\" left=\"0%\"}\n\n![](../images/regex_meme.png){.absolute height=\"50%\" top=\"40%\" left=\"55%\"}\n\n\n## Matching strings \n\nView string patterns with `stringr::str_view()`\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(x <- c(\"apple\", \"banana\", \"pear\", NA))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"apple\"  \"banana\" \"pear\"   NA      \n```\n\n\n:::\n\n```{.r .cell-code}\nstr_view(x, \"a\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] │ <a>pple\n[2] │ b<a>n<a>n<a>\n[3] │ pe<a>r\n```\n\n\n:::\n:::\n\n\n\n\n\n## Regex 101\n\n`.` is wildcard\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(x, \".a.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[2] │ <ban>ana\n[3] │ p<ear>\n```\n\n\n:::\n:::\n\n\n\n\n\n## Regex 101\n\n`^` to match the start of the string (like `starts_with()`)\n\n`$` to match the end of the string (like `ends_with()`)\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(x, \"^a\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] │ <a>pple\n```\n\n\n:::\n\n```{.r .cell-code}\nstr_view(x, \"a$\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[2] │ banan<a>\n```\n\n\n:::\n:::\n\n\n\n\n\n## Regex 101\n\n`|` matches one pattern OR another (e.g., `this|that`)\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(x, \"ap|an|ar\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] │ <ap>ple\n[2] │ b<an><an>a\n[3] │ pe<ar>\n```\n\n\n:::\n:::\n\n\n\n\n::: {.fragment}\nWrap character groups in `()`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(\"Are you here or are you there?\", \"(A|a)re\")  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] │ <Are> you here or <are> you there?\n```\n\n\n:::\n:::\n\n\n\n:::\n\n## Regex 101\n\n`\\d` matches any digit\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# view digits\nstr_view(\"March 10, 2025\", \"\\\\d\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] │ March <1><0>, <2><0><2><5>\n```\n\n\n:::\n:::\n\n\n\n\n\n## Regex 101\n\n`[abc]` matches individual characters (a, b, or c)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# view everything with ab or a<space>\nstr_view(c(\"abc\", \"a.c\", \"a*c\", \"a c\"), \"a[b ]\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] │ <ab>c\n[4] │ <a >c\n```\n\n\n:::\n:::\n\n\n\n\n\n## Regex 101\n\n`[^abc]` matches individual characters except a, b, or c\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# view everything except ab and a<space>\nstr_view(c(\"abc\", \"a.c\", \"a*c\", \"a c\"), \"a[^b ]\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[2] │ <a.>c\n[3] │ <a*>c\n```\n\n\n:::\n\n```{.r .cell-code}\n# view everything except digits\nstr_view(\"March 10, 2020\", \"[^\\\\d]\")  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] │ <M><a><r><c><h>< >10<,>< >2020\n```\n\n\n:::\n:::\n\n\n\n\n\n# Detecting and extracting patterns \n\n## Detecting pattern matches \n\nDetect matching elements with `stringr::str_detect()`\n\nReturns logical vector of elements that match pattern\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"apple\"  \"banana\" \"pear\"   NA      \n```\n\n\n:::\n\n```{.r .cell-code}\nstr_detect(x, \"e\")  # grepl() in base R\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE FALSE  TRUE    NA\n```\n\n\n:::\n:::\n\n\n\n\n::: {.fragment}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(str_detect(x, \"e\"), na.rm = TRUE)  # sum matching elements\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n\n```{.r .cell-code}\nmean(str_detect(x, \"e\"), na.rm = TRUE)  # calculate proportion of matches\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.6666667\n```\n\n\n:::\n:::\n\n\n\n:::\n\n\n## Extracting pattern matches\n\nExtract **observations** matching pattern with `filter()` and `str_detect()`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |>\n  filter(str_detect(sex, \"male\")) |>  # select observations that include \"male\"\n  select(species, island, sex)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 333 × 3\n   species island    sex   \n   <fct>   <fct>     <fct> \n 1 Adelie  Torgersen male  \n 2 Adelie  Torgersen female\n 3 Adelie  Torgersen female\n 4 Adelie  Torgersen female\n 5 Adelie  Torgersen male  \n 6 Adelie  Torgersen female\n 7 Adelie  Torgersen male  \n 8 Adelie  Torgersen female\n 9 Adelie  Torgersen male  \n10 Adelie  Torgersen male  \n# ℹ 323 more rows\n```\n\n\n:::\n:::\n\n\n\n\n\n## Extracting pattern matches\n\nExtract **elements** that match a pattern with `stringr::str_subset()`\n\nReturns elements that match pattern\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(words, n = 20)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"a\"         \"able\"      \"about\"     \"absolute\"  \"accept\"    \"account\"  \n [7] \"achieve\"   \"across\"    \"act\"       \"active\"    \"actual\"    \"add\"      \n[13] \"address\"   \"admit\"     \"advertise\" \"affect\"    \"afford\"    \"after\"    \n[19] \"afternoon\" \"again\"    \n```\n\n\n:::\n:::\n\n\n\n\n::: {.fragment}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_subset(words, \"^rec\")  # select elements starting with \"rec\"\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"receive\"   \"recent\"    \"reckon\"    \"recognize\" \"recommend\" \"record\"   \n```\n\n\n:::\n\n```{.r .cell-code}\nstr_subset(words, \"ing$\")  # select elements ending with \"ing\"\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"bring\"   \"during\"  \"evening\" \"king\"    \"meaning\" \"morning\" \"ring\"   \n[8] \"sing\"    \"thing\"  \n```\n\n\n:::\n:::\n\n\n\n:::\n\n\n<!-- ## Counting pattern matches  -->\n\n<!-- Count matches within an element with `stringr::str_count()` -->\n<!-- ```{r} -->\n<!-- str_count(x, \"e\") -->\n<!-- ``` -->\n\n<!-- ::: {.fragment} -->\n<!-- How is this different from `sum(str_detect(x, \"e\"))`? -->\n<!-- ```{r} -->\n<!-- sum(str_detect(x, \"e\")) -->\n<!-- ``` -->\n<!-- ::: -->\n\n\n<!-- ## Extracting pattern matches -->\n\n<!-- Extract matches patterns with `stringr::str_extract()` -->\n<!-- ```{r} -->\n<!-- head(sentences) -->\n<!-- str_extract(sentences, \"red|orange|yellow|green|blue|purple\") -->\n<!-- ``` -->\n\n\n<!-- ## Extracting pattern matches -->\n\n<!-- Extract **all** elements that match patterns with `stringr::str_extract_all()` -->\n<!-- ```{r} -->\n<!-- str_extract_all(sentences, \"red|orange|yellow|green|blue|purple\",  -->\n<!--                 simplify = TRUE) -->\n<!-- ``` -->\n\n\n# Replacing patterns\n\n\n## Replacing pattern matches\n\nReplace matches with new strings with `stringr::str_replace()` and `stringr::str_replace_all()`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_replace(x, \"[aeiou]\", \"-\")  # replace only first instance of match\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"-pple\"  \"b-nana\" \"p-ar\"   NA      \n```\n\n\n:::\n:::\n\n\n\n\n::: {.fragment}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_replace_all(x, \"[aeiou]\", \"-\")  # replace all matches\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"-ppl-\"  \"b-n-n-\" \"p--r\"   NA      \n```\n\n\n:::\n\n```{.r .cell-code}\nstr_replace_all(x, \"[^aeiou]\", \"-\")  # replace all matches\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"a---e\"  \"-a-a-a\" \"-ea-\"   NA      \n```\n\n\n:::\n:::\n\n\n\n:::\n\n::: {.fragment}\nHow do we do this based on position instead of pattern?\n:::\n\n\n## Replacing pattern matches\n\nYou *can* use this to recode character variables, but...\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(50)\npenguins |>\n  mutate(new_island = str_replace(island, \"Torgersen\", \"Party\")) |> \n  select(species, island, new_island) |> \n  slice_sample(n = 6)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 3\n  species   island    new_island\n  <fct>     <fct>     <chr>     \n1 Adelie    Torgersen Party     \n2 Chinstrap Dream     Dream     \n3 Adelie    Dream     Dream     \n4 Chinstrap Dream     Dream     \n5 Gentoo    Biscoe    Biscoe    \n6 Gentoo    Biscoe    Biscoe    \n```\n\n\n:::\n:::\n\n\n\nIt coerces to character data types\n\n::: {.fragment}\nI use this **A LOT** to clean up text data\n:::\n\n## Replacing `NA` \n\nReplace `NA` with another value with `dplyr::replace_na()`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"apple\"  \"banana\" \"pear\"   NA      \n```\n\n\n:::\n\n```{.r .cell-code}\nreplace_na(x, \"Missing\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"apple\"   \"banana\"  \"pear\"    \"Missing\"\n```\n\n\n:::\n:::\n\n\n\n\n\n# Splitting strings\n\n\n## Splitting strings\n\nSplit a string up into pieces with str_split()\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(sentences, n = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"The birch canoe slid on the smooth planks.\" \n[2] \"Glue the sheet to the dark blue background.\"\n```\n\n\n:::\n\n```{.r .cell-code}\nsentences |>\n  head(2) |>\n  str_split(\" \")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] \"The\"     \"birch\"   \"canoe\"   \"slid\"    \"on\"      \"the\"     \"smooth\" \n[8] \"planks.\"\n\n[[2]]\n[1] \"Glue\"        \"the\"         \"sheet\"       \"to\"          \"the\"        \n[6] \"dark\"        \"blue\"        \"background.\"\n```\n\n\n:::\n:::\n\n\n\n\n::: {.fragment}\nNotice this produces a list. Why?\n:::\n\n\n## Splitting strings\n\nConvert to matrix with `simplify`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsentences[c(1:2, 5)] |>\n  str_split(\" \", simplify = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1]   [,2]    [,3]    [,4]     [,5]  [,6]    [,7]     [,8]         \n[1,] \"The\"  \"birch\" \"canoe\" \"slid\"   \"on\"  \"the\"   \"smooth\" \"planks.\"    \n[2,] \"Glue\" \"the\"   \"sheet\" \"to\"     \"the\" \"dark\"  \"blue\"   \"background.\"\n[3,] \"Rice\" \"is\"    \"often\" \"served\" \"in\"  \"round\" \"bowls.\" \"\"           \n```\n\n\n:::\n:::\n\n\n\n\n\n<!-- ## Splitting strings -->\n\n<!-- Split into specific number of pieces -->\n<!-- ```{r} -->\n<!-- (fields <- c(\"Name: Hadley\", \"Country: NZ\", \"Age: 35\")) -->\n<!-- fields |> str_split(\": \", n = 2, simplify = TRUE) -->\n<!-- ``` -->\n\n\n## Solving the problem\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nnrows <- 12\nset.seed(100)\ndata1 <- tibble(time = rep(c(\"early-day\", \"mid-day\", \"late-day\", \"daytime\"), \n                           times = 3), \n                species = sample(c(\"dog\", \"dogfish\", \"bear dog\", \"cat\", \"catfish\"), \n                                 nrows, replace = TRUE), \n                resp = sample(c(\"yes\", \"no\", \"yes\", \"no\", NA), nrows, \n                              replace = TRUE))\n```\n:::\n\n\n\n\n## Solving the problem\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```{style='font-size: 50%'}\n# A tibble: 12 × 3\n   time      species  resp \n   <chr>     <chr>    <chr>\n 1 early-day dogfish  yes  \n 2 mid-day   bear dog no   \n 3 late-day  dog      yes  \n 4 daytime   dogfish  no   \n 5 early-day cat      yes  \n 6 mid-day   cat      no   \n 7 late-day  dogfish  no   \n 8 daytime   bear dog no   \n 9 early-day dogfish  <NA> \n10 mid-day   catfish  yes  \n11 late-day  cat      yes  \n12 daytime   bear dog yes  \n```\n\n\n:::\n:::\n\n\n\n:::\n\n::: {.column width=\"50%\"}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```{style='font-size: 50%'}\n# A tibble: 8 × 3\n  time      species  resp   \n  <chr>     <chr>    <chr>  \n1 early-Day dogfish  yes    \n2 mid-Day   bear dog no     \n3 late-Day  dog      yes    \n4 daytime   dogfish  no     \n5 late-Day  dogfish  no     \n6 daytime   bear dog no     \n7 early-Day dogfish  no data\n8 daytime   bear dog yes    \n```\n\n\n:::\n:::\n\n\n\n:::\n\n::::\n\n\n## Let's code!\n\n[Matching patterns](../code/21_patterns.html){target=\"_blank\"}\n",
    "supporting": [
      "21_patterns_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}