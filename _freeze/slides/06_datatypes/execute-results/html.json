{
  "hash": "61722e7bcbd345a61dc39135cca2778b",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Data types\"\nauthor: \"Jeff Stevens\"\ndate: \"2023-02-03\"\ndate-format: iso\nexecute:\n  echo: true\n  freeze: auto\nformat:\n  revealjs: \n    theme: custom.scss\n    slide-number: true\n    code-link: true\n    code-line-numbers: false\n    highlight-style: github\n    code-overflow: wrap\n    footer: \"[DPaViR 2025](https://jeffreyrstevens.quarto.pub/dpavir2025)\"\n    logo: \"../logo/dpavir_hex.png\"\n---\n\n\n\n\n# Review\n\n## Mental model of literate programming\n\n![](../images/mentalmodel_rmarkdown.png){fig-align=\"center\"}\n\n\n# Data types\n\n## Data types\n\n### Formats of individual elements\n\n* Double\n\n* Integer\n\n* Character\n\n* Logical\n\n#### Check data types with `typeof()`\n\n\n## Mental model of data types\n\n![](../images/mentalmodel_datatypes.png){fig-align=\"center\"}\n\n\n---\n\n## Numeric data\n\n### Doubles\n\n#### Floating-point numbers with decimals\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# assign value 7.2 to object a\n(a <- 7.2) # remember, wrapping in parentheses prints to console\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 7.2\n```\n\n\n:::\n:::\n\n\n\n\n:::{.fragment}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n:::\n\n\n\n:::\n\n\n---\n\n## Numeric data\n\n### Integers\n\n#### Numbers without decimals\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(b <- 7)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 7\n```\n\n\n:::\n:::\n\n\n\n\n:::{.fragment}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(b)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n:::\n\n\n\n\n:::{.callout-note}\n#### Doubles can have 0 as decimal\n:::\n:::\n\n---\n\n## Numeric data\n\n### Integers\n\n#### Numbers without decimals (specified with `L`)\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(c <- 7L)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 7\n```\n\n\n:::\n:::\n\n\n\n\n:::{.fragment}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(c)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n:::\n\n\n\n:::\n\n\n---\n\n## Character data\n\n#### Must be surrounded by `\"\"`\n\n:::{.fragment}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(d <- \"Hello, world\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Hello, world\"\n```\n\n\n:::\n\n```{.r .cell-code}\n(e <- \"7\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"7\"\n```\n\n\n:::\n:::\n\n\n\n:::\n\n:::{.fragment}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(e)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n\n\n:::\n\n## Let's explore!\n\n:::{.incremental}\n* Type `b`, `c`, and `e` into the console separately. What do you see?\n* Add `b + c`.\n* Add `b + e`.\n:::\n\n---\n\n## Logical\n\n#### Tests whether conditional statement is `TRUE` or `FALSE` (notice always all upper case)\n#### Logical operators: `>`, `>=`, `<`, `<=`, `==`, `!=`, `%in%`\n\n:::{.fragment}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\na\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 7.2\n```\n\n\n:::\n\n```{.r .cell-code}\na > 5\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n:::\n\n:::{.fragment}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Hello, world\"\n```\n\n\n:::\n\n```{.r .cell-code}\n(mytest <- d == \"Good-bye, world\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n\n\n:::\n\n:::{.fragment}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(mytest)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"logical\"\n```\n\n\n:::\n:::\n\n\n\n:::\n\n---\n\n## Logical\n\n#### The logical operator for equals is `==`\n\n:::{.callout-note}\nWe use\n\n* `==` for logical equals\n* `<-` for assigning objects\n* `=` for assigning function argument values to argument names\n:::\n\n\n---\n\n## Logical\n\n#### `%in%` operator: \"is contained in\"\n\n:::{.fragment}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(subjects <- c(\"01\", \"02\", \"03\", \"04\", \"05\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"01\" \"02\" \"03\" \"04\" \"05\"\n```\n\n\n:::\n:::\n\n\n\n:::\n\n:::{.fragment}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\"03\" %in% subjects\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n:::\n\n:::{.fragment}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\"06\" %in% subjects\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n\n\n:::\n\n:::{.fragment}\n#### Test \"is NOT contained in\" with `!` before test string\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n!\"06\" %in% subjects\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n:::\n\n---\n\n## Augmented data types\n\n#### Core data types with special attributes\n\n* Factors\n\n* Dates\n\n---\n\n## Factors\n\n#### Augmented integers with 'levels'\n\n:::{.fragment}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(i <- factor(\"married\", levels = c(\"single\", \"married\", \"widowed\")))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] married\nLevels: single married widowed\n```\n\n\n:::\n:::\n\n\n\n:::\n\n:::{.fragment}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(i)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n:::\n\n\n\n:::\n\n:::{.fragment}\n:::{.callout-note}\nUse `class()` to view augmented data type\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(i)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"factor\"\n```\n\n\n:::\n:::\n\n\n\n:::\n:::\n\n---\n\n## Dates \n#### Augmented numerics based on number of days since 1970-01-01\n\n:::{.fragment}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(j <- as.Date(\"1970-01-01\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1970-01-01\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(j)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(j)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Date\"\n```\n\n\n:::\n:::\n\n\n\n\n:::{.callout-note}\nMake sure to wrap dates in `\"\"`\n:::\n:::\n\n\n---\n\n## Dates \n\n#### You can do math on dates\n\n:::{.fragment}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(k <- as.Date(\"2023-02-03\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2023-02-03\"\n```\n\n\n:::\n\n```{.r .cell-code}\nk-j\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nTime difference of 19391 days\n```\n\n\n:::\n:::\n\n\n\n:::\n\n\n---\n\n## Check data types\n\n* Check with `typeof()`/`class()`\n\n:::{.fragment}\n* Check in RStudio\n:::\n\n:::{.fragment}\n* Use `is.<type>()` functions: <br>\n`is.logical()`, `is.numeric()`, `is.character()`\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis.character(7)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nis.character(\"7\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n\n:::\n\n\n---\n\n## Converting between data types (coercion)\n\n:::{.fragment}\n#### Use `as.<type>()` functions: \n`as.logical()`, `as.numeric()`, `as.character()`\n:::\n\n:::{.fragment}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ne\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"7\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(e)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n\n```{.r .cell-code}\n(l <- as.numeric(e))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 7\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(l)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n:::\n\n\n\n:::\n\n---\n\n## Converting between data types (coercion)\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(m <- \"TRUE\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"TRUE\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(m)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n\n```{.r .cell-code}\n(n <- as.logical(m))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"logical\"\n```\n\n\n:::\n:::\n\n\n\n\n\n---\n\n## Converting between data types (coercion)\n\n#### Factors to numerics is tricky\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(o <- factor(0, levels = c(\"1\", \"0\")))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0\nLevels: 1 0\n```\n\n\n:::\n\n```{.r .cell-code}\nas.numeric(o)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n:::\n\n\n\n\n:::{.fragment}\n#### First coerce to character\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.character(o)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"0\"\n```\n\n\n:::\n\n```{.r .cell-code}\nas.numeric(as.character(o))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0\n```\n\n\n:::\n:::\n\n\n\n:::\n\n\n---\n\n## Special values\n\n#### `NA` represents missing values\n\n* Each data type has its own type of `NA`\n\n* Check with `is.na()`\n\n\n:::{.fragment}\n#### `NaN` means \"not a number\" (undefined)\n\n* `0 / 0 = NaN`\n:::\n\n\n:::{.fragment}\n#### `Inf` and `-Inf` represent infinity and negative infinity\n\n* `1 / 0 = Inf`\n\n* `-1 / 0 = -Inf`\n:::\n\n## Mental model of data types\n\n![](../images/mentalmodel_datatypes.png){fig-align=\"center\"}\n\n\n## Let's code!\n\n[Data types coding](../code/06_datatypes.html){target=\"_blank\"} [[Rmd](../code/06_datatypes.Rmd){target=\"_blank\"}]\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}